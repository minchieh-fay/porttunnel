# porttunnel
端口隧道

bridge和proxy都是这个程序porttunnel

根据不同环境变量启动不同的模块


bridge: 下层网络（他能主动连上层proxy）
他能帮忙把流量桥接到局域网的资源服务器（如：某个web服务器）

proxy：给客户使用的代理，处于上层网络（他不能主动连下层bridge）
他能将客户发过来的请求（如http请求），通过bridge的长链接发送给bridge局域网中的资源服务器

proxy的环境变量：
TUNPORT=隧道数据端口 //默认：5566 用于给bridge链接，和业务无关，需要让甲方开端口  给下层bridge使用
// 这个端口是给下层bridge使用的，所以需要暴露给bridge使用，可以使用host模式启动容器，或者进行端口映射出去

bridge的环境变量：
SERVER={ip}:{port}  // 上层服务proxy的地址，其中port要对印上TUNPORT
PORT[n]=tcp/udp:{server代理的端口}:{资源ip}:{资源port} // 例如：PORT1=tcp:80:10.35.148.167:8080
// 如果有多个映射， n可以从1开始依次加， 但是不能跳跃，即没有定义PORT1，不能定义PORT2




该程序使用quic
开发语言golang

客户端和服务端都是他

根据环境变量启动不同的效果

TCPTUN=“5000:”

我现在有2台机器A，B
现在A能连上B。B不能主动连A

我计划用golang写一个程序。
A用tcp/UDP主动连上B

这时候B机器上面的程序就可以通过这个链路。反向去连A局域网中的其他web服务等
B：
开放本地端口5000。给他本机的其他程序使用
5001端口被A连

A：
所在的机器上面有很多web微服务
他能连上B的5001端口（tcp和udp都可以）

这种情况是无法使用nginx代理的

需要用golang写一个逆向的代理

用什么技术实现呢？ quic？ libp2p


建立一个从B到A的反向隧道，使得B可以通过A主动建立的连接访问A所在局域网的其他服务。以下是几种可行的技术方案：

方案1：基于TCP/UDP的简单反向代理

架构设计

A机器程序：
作为客户端主动连接B的5001端口
维持这个长连接作为控制通道
接收B的请求并转发到本地服务
B机器程序：
监听5001端口等待A连接
监听5000端口供本地应用使用
通过A建立的连接转发5000端口的请求
